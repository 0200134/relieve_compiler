use crate::ast::*; 
use crate::ast::{Program, FunctionDefinition, Statement, Expression, LiteralValue, FunctionCall};
use crate::types::RelieveType; 

// This file is the code generator that converts the AST into Rust code.

pub struct Codegen;

impl Codegen {
    // Codegen 구조체의 생성자입니다.
    pub fn new() -> Self {
        Codegen {}
    }

    // Main entry point for code generation
    pub fn generate_program(&self, program: &Program) -> String {
        let mut output = String::new();
        output.push_str("// Generated by the Relieve Compiler\n\n");
        
        // Simplified entry point: Generate fn main() {} wrapper and process function definitions inside it
        output.push_str("fn main() {\n"); 

        for def in &program.definitions {
            match def {
                Definition::Function(func_def) => {
                    output.push_str(&self.generate_function_definition(func_def));
                }
                // TODO: Add struct/enum definitions
            }
        }

        output.push_str("}\n");
        output
    }

    // FunctionDefinition 구조체 사용
    fn generate_function_definition(&self, func: &FunctionDefinition) -> String {
        let mut code = String::new();
        
        // Relieve functions map to Rust functions (only main is supported now)
        if func.name == "main" {
            // Hardcode main signature for simplicity now, ignoring parameters/return type
        } else {
             // For simplicity, we are only generating the main block content for now.
             // Real function generation would involve:
             // format!("fn {}({}) -> {} {{\n", func.name, params, return_type)
        }

        // Generate statements from the Block structure (func.body.statements 사용)
        code.push_str(&self.generate_statements(&func.body.statements, 1));
        
        // Note: The main wrapper fn main() {} is already in generate_program, 
        // so we only return the body content here.
        code
    }

    // Statement 구조체 사용
    fn generate_statements(&self, statements: &[Statement], indent_level: usize) -> String {
        let mut code = String::new();
        let indent = "    ".repeat(indent_level);

        for stmt in statements {
            match stmt {
                Statement::FunctionCall(func_call) => {
                    code.push_str(&format!("{}{};\n", indent, self.generate_function_call(func_call)));
                }
                Statement::VariableDeclaration { name, type_hint, initializer, is_mutable } => { 
                    // type_hint는 Option<RelieveType>이므로 언랩핑 필요
                    let type_str = match type_hint {
                        // types.rs에 맞춰 Integer와 Boolean으로 변경
                        Some(RelieveType::Integer) => "i64".to_string(),
                        Some(RelieveType::String) => "String".to_string(),
                        Some(RelieveType::Boolean) => "bool".to_string(),
                        Some(RelieveType::Unit) | None => "()".to_string(),
                        _ => "()".to_string(), // Unknown type fallback
                    };
                    let init_code = self.generate_expression(initializer);
                    
                    let mut_keyword = if *is_mutable { "mut " } else { "" };

                    code.push_str(&format!("{}let {}{}: {} = {};\n", indent, mut_keyword, name, type_str, init_code));
                }
            }
        }
        code
    }

    // FunctionCall 구조체 사용
    fn generate_function_call(&self, func_call: &FunctionCall) -> String {
        let args: Vec<String> = func_call.arguments.iter()
            .map(|expr| self.generate_expression(expr))
            .collect();
        
        // Handle built-in mapping: print_ln -> println!
        let name = if func_call.name == "print_ln" {
            "println!".to_string()
        } else {
            func_call.name.clone()
        };

        format!("{}({})", name, args.join(", "))
    }

    // Expression 구조체 사용
    fn generate_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(lit) => self.generate_literal(lit),
            Expression::Identifier(name) => name.clone(), // 변수 이름 (예: args)
            Expression::FunctionCall(func_call) => self.generate_function_call(func_call), 
            // 모든 베리언트가 명시적으로 처리되므로 unreachable pattern 경고 제거
        }
    }

    // LiteralValue 구조체 사용
    fn generate_literal(&self, lit: &LiteralValue) -> String {
        match lit {
            LiteralValue::String(s) => format!("{:?}", s), // Use {:?} for Rust string representation
            LiteralValue::Integer(i) => i.to_string(),
            LiteralValue::Boolean(b) => b.to_string(),
        }
    }
}
